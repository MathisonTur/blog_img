# Redis 基础知识

## 一、初识 Redis

### 1.1 NoSQL

> 对比 SQL 与 NoSQL 的区别

- SQL：关系型数据库
- NoSQL：非关系型数据库

#### 1. 1.1 数据结构

##### 1. SQL

- 结构化（Structured）
- ![image-20221129224752320](1.%20Redis%20%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86.assets/image-20221129224752320.png)

##### 2. NoSQL

- 非结构化
- ![image-20221129225146820](1.%20Redis%20%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86.assets/image-20221129225146820.png)



#### 1.1.2 数据关联

##### 1. SQL

- 关联的（Relational）
- ![image-20221129225809198](1.%20Redis%20%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86.assets/image-20221129225809198.png)

##### 2. NoSQL

- 无关联的



#### 1.1.3 查询方式

##### 1. SQL

- SQL 查询
- ![image-20221129225923492](1.%20Redis%20%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86.assets/image-20221129225923492.png)

##### 2. NoSQL

- 非 SQL
- ![image-20221129225951166](1.%20Redis%20%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86.assets/image-20221129225951166.png)

> ![image-20221129230007224](1.%20Redis%20%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86.assets/image-20221129230007224.png)



#### 1.1.4 事务特性

##### 1. SQL

- ACID
- ![image-20221129230120185](1.%20Redis%20%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86.assets/image-20221129230120185.png)

##### 2. NoSQL

- BASE

> - 键值类型（Redis）
> - 文档类型（MongoDB）
> - 列类型（HBase）
> - Graph 类型（Neo4j）



### 1.2 Redis 简介

`Redis`（Remote Dictionary Server），远程词典服务器，是一个基于内存的键值型 NoSQL 数据库

特征：

- 键值（`key-value`）型，value 支持多种不同数据结构，功能丰富
- 单线程，每个命令具备原子性
- 低延迟，速度快（基于内存、IO多路复用、良好的编码）
- 支持数据持久化
- 支持主从集群、分片集群
- 支持多语音客户端

--------



## 二、Redis 常见命令

### 2.1 Redis 数据结构

`Redis `是一个` key-value `的数据库，`key `一般是 `String `类型，不过 `value `的类型多种多样

- String：如 “hello world”
- Hash：{ name: “Jack”, age: 21 }
- List：[ A -> B -> C -> C ]
- Set：{ A, B, C}
- SortedSet：{ A: 1, B: 2, C: 3 }

- GEO：{ A: (120.3, 30.5 ) }
- BitMap：0110110101110101011
- HyperLog：0110110101110101011

![image-20230329163417027](1.%20Redis%20%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86.assets/image-20230329163417027.png)

Redis 将操作不同数据类型的命令做了分组，在官网（https://redis.io/commands）可以查到不同命令

![image-20221130095432799](1.%20Redis%20%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86.assets/image-20221130095432799.png)



### 2.2 Redis 通用命令

通用指令是部分数据类型都可用使用的指令，常见的有：

- `KEYS`：查看复合模板的所有 `key`，<font color='red'>不建议在生产环境设备上使用</font>
- `DEL`：删除一个指定的 `key`
- `EXISTS`：判断 `key `是否存在
- `EXPIRE`：给一个 `key` 设置有效期，有效期到期时，该 `key `会被自动删除
- `TTL`：查看一个 `key `的剩余有效期

> 通过 `help [command]` 可以查看一个命令的具体用法
>
> ![image-20221130101123021](1.%20Redis%20%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86.assets/image-20221130101123021.png)



### 2.3 String 类型

#### 2.3.1 String 类型的三种格式

`String `类型，即字符串类型，是 `Redis `中最简单的存储类型，其 `value` 是字符串，不过根据字符串的格式不同，可以分为如下3类：

- `string`：普通字符串
- `int`：整数类型，可以做自增、自减操作
- `float`：浮点类型，可以做自增、自减操作

> 不管是哪种格式，底层都是字节数组形式存储，只不过编码方式不同。字符串类型的最大空间不能超过 512m



#### 2.3.2 String 类型的常见命令

`String `的常见命令有：

- `SET`：添加或者修改已经存在的一个 String 类型的键值对
- `GET`：根据 key 获取 String 类型的 value
- `MSET`：批量添加多个 String 类型的键值对
- `MGET`：根据多个 key 获取多个 String 类型的 value
- `INCR`：让一个整型的 key 自增1
- `INCRBY`：让一个整型的 key 自增并指定步长。例如：incrby num 2 让 num 值自增 2
- `INCRBYFLOAT`：让一个浮点类型的数字自增并指定步长
- `SETNX`：添加一个 String 类型的键值对，前提是这个 key 不存在，否则不执行
- `SETEX`：添加一个 String 类型的键值对，并且指定有效期



#### 2.3.3 key的结构

> 问题：如何区分不同类型的 key。例如：需要存储用户、商品信息到redis，有一个用户id是1，有一个商品id恰好也是1

`Redis `的 `key `允许有多个单词形成层级结构，多个单词之间用 `: `隔开，格式如下：

![image-20221130150154494](1.%20Redis%20%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86.assets/image-20221130150154494.png)

> 格式并非固定，可以根据需求来删除或添加词条

示例如下：

项目名称：hotel，有 user 和 product 两种不同类型的数据，定义 key 如下：

- user 相关的 key：hotel:user:1
- product 相关的 key：hotel:product:1

若 Value 是一个 Java 对象，如一个 User 对象，则可由将对象序列化为 JSON 字符串后存储

![image-20221130185855534](1.%20Redis%20%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86.assets/image-20221130185855534.png)



### 2.4 Hash 类型

#### 2.4.1 Hash 结构

Hash 类型，也叫散列，其 value 是一个无序字典，类似于 Java 中的 HashMap 结构

> 问题：String 结构是将对象序列化为 JSON 字符串后存储，当需要修改对象的某个字段时很不方便：
>
> ![image-20221130190238185](1.%20Redis%20%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86.assets/image-20221130190238185.png)

Hash 结构可以将对象中的的每个字段独立存储，可以针对单个字段做 CRUD

![image-20221130191443785](1.%20Redis%20%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86.assets/image-20221130191443785.png)



#### 2.4.2 Hash 类型常用命令

`Hash `的常见命令有：

- `HSET key field value`：添加或者修改 hash 类型 key 的 field 的值
- `HGET key field`：获取一个 hash 类型 key field 的值
- `HMSET`：批量添加多个 hash类型 key 的 field 的值
- `HMGET`：批量获取多个 hash 类型 key 的 field 的值
- `HGETALL`：获取一个 hash 类型的 key 中的所有的 field 和 value
- `HKEYS`：获取一个 hash 类型的 key 中的所有的 field
- `HVALS`：获取一个 hash 类型的 key 中的所有的 value
- `HINCRBY`：让一个 hash 类型 key 的字段值自增并指定步长
- `HSETNX`：添加一个 hash 类型的 key 的 field 值，前提是这个 field 不存在，否则不执行



### 2.5 List 类型

#### 2.5.1 List 类型简介

Redis 中的 `List `类型与 Java 中的 `LinkedList `类似，可以看做是一个<font color='red'>双向链表结构</font>，即支持正向检索也支持方向检索

`List `类型的特征也与 `LinkedList `类似：

- 有序
- 元素可以重复
- 插入和删除快
- 查询速度一般

常用来存储一个<font color='red'>有序数据</font>，例如：朋友圈点赞列表，评论列表



#### 2.5.2 List 类型的常见命令

- `lpush key element … `：项列表左侧插入一个或多个元素
- `lpop key`：移除并返回列表左侧的第一个元素，没有则返回 nil
- `rpush key elemnt … `： 项列表右侧插入一个或多个元素
- `rpop key`：移除并返回列表右侧的第一个元素
- `lrange key star end`：返回一段角标范围内的所有元素
- `blpop 和 brpop`：与 lpop 和 rpop 类似，只不过在没有元素时等待指定时间，而不是直接返回 nil

![image-20221130200304385](1.%20Redis%20%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86.assets/image-20221130200304385.png)

> 1. 如何利用 List 结构模拟一个栈：
>    - 入口和出口在同一边
> 2. 如何利用 List 结构模拟一个队列：
>    - 入口和出口不在同一边
> 3. 如何利用 List 结构模拟一个阻塞队列：
>    - 入口和出口在不同边
>    - 出队时 `BLPOP `或 `BRPOP`

 

### 2.6 Set 类型

#### 2.6.1 Set 结构

Redis 的 Set 结构与 Java 中的 HashSet 类似，可以看做是一个 value 为 null 的 HashMap

具备与 Hash Set 类似的特征：

- 无序
- 元素不可重复
- 查找快
- 支持交集、并集、差集等功能

#### 2.6.2 Set 的常见命令

- `sadd key member …` ： 向 set 中添加一个或多个元素
- `srem key member …` ：移除 set 中的指定元素
- `scard key`：返回 se 中元素的个数
- `sismember key member`：判断一个元素是否存在于 set 中
- `smembers`：获取 set 中的所有元素
- `sinter key1 key2 …` ： 求 key1 和 key2 的交集

- `sdiff key1 key2 … `：求 key1 和 key2 的差集
- `sunion key1 ke2 … `：求 key1 和 key2 的并集

![image-20221130210806789](1.%20Redis%20%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86.assets/image-20221130210806789.png)



### 2.7 SortedSet 类型

#### 2.7.1 SortedSet 类型

Redis 的 SortedSet 是一个可排序的 set 集合，与 Java 中的 TreeSet 有些类似，但底层数据结构差别很大

SortedSet 中的每个元素都带有一个 score 属性，可以基于 score 属性对元素进行排序，底层的实现是一个跳表（SkipList）加 hash 表

SortedSet 具备以下特性：

- 可排序
- 元素不重复
- 查询速度快

> 因为 SortedSet 的可排序特性，经常被用来实现排行榜这样的功能

#### 2.7.2 SortedSet 的常见命令

- `zadd key score member`：添加一个或多个元素到 sorted set， 若已经存在则更新其 score 值
- `zrem key member `：删除 sorted set 中的一个指定元素
- `zscore key member`：获取 sorted set 中的指定元素的 score 值
- `zrank key member`：获取 sorted set 中指定元素的排名
- `zcard key`：获取 sorted set 的元素个数
- `zcount key min max`：统计 score 值在给定范围内的所有元素的个数
- `zincrby key increment member`：让 sorted set 中的指定元素自增，步长为指定的 increment 值
- `zrange key min max`：按照 score 排序后，获取指定排名范围内的元素，这是个左开右闭的区间
- `zrangebyscore key min max`：按照 score 排序后，获取指定 score 范围内的元素
- `zdiff、zinter、zunion`：求差集、交集、并集

> ==注意：==所有的排名都是默认升序，若需要降序则在命令的 Z 后面添加 rev 即可

------------



## 三、Redis 的 Java 客户端

在Redis官网中提供了各种语言的客户端，地址：https://redis.io/clients

![image-20221201095200934](1.%20Redis%20%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86.assets/image-20221201095200934.png)

![image-20221201095300937](1.%20Redis%20%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86.assets/image-20221201095300937.png)



### 3.1 Jedis

> jedis 官网地址：https://github.com/redis/jedis

#### 3.1.1 Jedis 的基本使用

Jedis 的使用步骤如下：

- 引入依赖
- 创建 Jedis 对象，建立连接
- 使用 Jedis，方法名与 Redis 命令一致
- 释放资源

具体如下：

1. 引入依赖：

   ```xml
   <!-- redis 依赖 -->
   <dependency>
        <groupId>redis.clients</groupId>
        <artifactId>jedis</artifactId>
        <version>4.3.1</version>
   </dependency>
   ```

2. 建立连接：

   ```java
   import org.junit.jupiter.api.BeforeEach;
   import redis.clients.jedis.Jedis;
   
   public class RedisTest {
       private Jedis jedis;
   
       /**
        * 建立连接
        * */
       @BeforeEach
       public void setUp(){
           // 建立连接
           jedis = new Jedis("127.0.0.1", 6379);
           // 设置密码
           jedis.auth("123456");
           // 选择库
           jedis.select(0);
       }
   }
   
   ```

3. 测试 String

   ```java
   import org.junit.jupiter.api.Test;
   ....
   public class RedisTest {
       ...
       /**
        * 测试 String
        * */
       @Test
       void testString(){
           // 插入数据，方法名称即redis命令的名称
           String result = jedis.set("name", "张三");
           System.out.println("result = " + result);
           // 获取数据
           String name = jedis.get("name");
           System.out.println("name = " + name);
       }
   }
   ```

4. 释放资源：

   ```java
   import org.junit.jupiter.api.AfterEach;
   public class RedisTest {
   	...
       /**
        * 释放资源
        * */
       @AfterEach
       public void tearDown(){
           // 释放资源
           if(jedis != null){
               jedis.close();
           }
       }
   }
   ```

5. 测试结果：

   ![image-20221201100027562](1.%20Redis%20%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86.assets/image-20221201100027562.png)

#### 3.1.2 Jedis 连接池

Jedis 本身是线程不安全的，并且频繁的创建和销毁连接会有性能损耗，因此推荐使用 Jedis 连接池代替 Jedis 的直连方式

```java
public class JedisConnectionFactory {
    private static final JedisPool jedisPool;
    
    static {
        JedisPoolConfig jedisPoolConfig = new JedisPoolConfig();
        // 最大连接数
        jedisPoolConfig.setMaxTotal(8);
        // 最大空闲连接
        jedisPoolConfig.setMaxIdle(8);
        // 最小空闲连接
        jedisPoolConfig.setMinIdle(0);
        // 设置最长等待时间，ms
        jedisPoolConfig.setMaxWaitMillis(200);
        jedisPool = new JedisPool(jedisPoolConfig, "127.0.0.1", 6379, 1000, "123456");
    }

    /**
     * 获取Jedis对象
     * */
    public static Jedis getJedis() {
        return jedisPool.getResource();
    }
}
```



### 3.2 SpringDataRedis

SpringData 是 Spring中数据操作的模块，包含对各种数据库的集成，其中对 Redis 的集成模块为 SpringDataRedis，官网地址：https://spring.io/projects/spring-data-redis

- 提供了对不同Redis客户端的整合（Lettuce和Jedis）

- 提供了RedisTemplate统一API来操作Redis

- 支持Redis的发布订阅模型

- 支持Redis哨兵和Redis集群

- 支持基于Lettuce的响应式编程

- 支持基于JDK、JSON、字符串、Spring对象的数据序列化及反序列化

- 支持基于Redis的JDKCollection实现

#### 3.2.1 SpringDataRedis 的基本使用

SpringDataRedis 中提供了 RedisTemplate 工具类，其中封装了各种对 Redis 的操作，并且将不同数据类型的操作 API 封装到了不同的类型中

|             API             |   返回值类型    |         说明         |
| :-------------------------: | :-------------: | :------------------: |
| redisTemplate.opsForValue() | ValueOperations | 操作 String 类型数据 |
| redisTemplate.opsForHash()  | HashOperations  |  操作 Hash 类型数据  |
| redisTemplate.opsForList()  | ListOperations  |  操作 List 类型数据  |
|  redisTemplate.opsForSet()  |  SetOperations  |  操作 Set 类型数据   |
| redisTemplate.opsForZSet()  | ZSetOperations  |  操作 ZSet 类型数据  |
|        redisTemplate        |                 |       通用命令       |

SpringDataRedis 的使用步骤如下：

- 引入 spring-boot-starter-data-redis 依赖
- 在 application.yml 中配置 Redis 信息
- 注入 RedisTemplate 

具体步骤如下：

1. 引入依赖

   ```xml
   <!-- Redis依赖 -->
   <dependency>
       <groupId>org.springframework.boot</groupId>
       <artifactId>spring-boot-starter-data-redis</artifactId>
   </dependency>
   <!-- 连接池依赖 -->
   <dependency>
       <groupId>org.apache.commons</groupId>
       <artifactId>commons-pool2</artifactId>
   </dependency>
   ```

2. 对 Redis 进行配置

   ```yml
   spring:
     redis:
       host: 127.0.0.1
       port: 6379
       password: 123456
       lettuce:
         pool:
           max-active: 8 # 最大连接
           max-idle: 8 # 最大空闲连接
           min-idle: 0 # 最小空闲连接
           max-wait: 200 # 连接等待时间
   ```

3. 注入 RedisTemplate

   ```java
   @Autowired
   private RedisTemplate redisTemplate;
   ```

4. 测试

   ```java
   @SpringBootTest
   public class SpringDataRedisTest {
       @Autowired
       private RedisTemplate redisTemplate;
   
       @Test
       void testString(){
           // 插入数据
           redisTemplate.opsForValue().set("name","李四");
           // 读取数据
           Object name = redisTemplate.opsForValue().get("name");
           System.out.println("name = " + name);
       }
   }
   ```



#### 3.2.2 SpringDataRedis 的序列化形式

`RedisTemplate `可以接收任意 `Object `作为值写入 `Redis`，只不过写入前会把 `Object `序列化为 字节形式，默认是采用 <font color='red'>JDK 序列化</font>

![image-20221201161846388](1.%20Redis%20%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86.assets/image-20221201161846388.png)

缺点：

- 可读性差
- 内存占用较大

解决方法：<font color='red'>自定义 RedisTemplate 序列化方式</font>

1. 自定义 RedisTemplate
2. 修改 RedisTemplate 的序列化器为 GenericJackson2JsonRedisSerializer

```java
 /**
     * 自定义序列化方式
     * */
    @Bean
    public RedisTemplate<String, Object> redisTemplate(RedisConnectionFactory factoryon){
        // 创建 Template
        RedisTemplate<String, Object> redisTemplate = new RedisTemplate<>();
        // 设置连接工厂
        redisTemplate.setConnectionFactory(factoryon);
        // 设置序列化工具
        GenericJackson2JsonRedisSerializer jsonRedisSerializer = new GenericJackson2JsonRedisSerializer();
        // key 和 hash key 采用 string 序列化
        redisTemplate.setKeySerializer(RedisSerializer.string());
        redisTemplate.setHashKeySerializer(RedisSerializer.string());
        // value 和 hashValue 采用 JSON 序列化
        redisTemplate.setValueSerializer(jsonRedisSerializer);
        redisTemplate.setHashValueSerializer(jsonRedisSerializer);
        return redisTemplate;
    }
```

测试：

```java
@Data
@AllArgsConstructor
@NoArgsConstructor
public class User {
    private String name;
    private int age;
}
```

```java
@SpringBootTest
public class SpringDataRedisTest {
    @Autowired
    private RedisTemplate redisTemplate;
    @Test
    void testUser(){
        User user = new User("张三", 20);
        //
        redisTemplate.opsForValue().set("user:101", user);
        //
        Object object = redisTemplate.opsForValue().get("user:101");
        System.out.println(object);
    }
}
```

测试效果：

![image-20221201163630093](1.%20Redis%20%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86.assets/image-20221201163630093.png)



#### 3.2.3 StringRedisTemplate

上述自定义序列化方式中使用的 JSON 序列化方式，虽然可以满足需求，但仍存在一些问题：为了在反序列化时知道对象的类型，JSON 序列化器会将类的 class 类型写入 json 结果中，存入 Redis，会带来<font color='red'>额外的内存开销</font>

![image-20221201164227016](1.%20Redis%20%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86.assets/image-20221201164227016.png)

为了节省内存空间，不使用 JSON 序列化器来处理 value，而是统一使用 String 序列化器，要求只能存储 String 类型的 key 和 value。当需要存储 Java 对象时，手动完成对象的序列化和反序列化

![image-20221201165453196](1.%20Redis%20%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86.assets/image-20221201165453196.png)

Spring 默认提供了一个 StringRedisTemplate 类，其 key 和 value 的序列化方式默认就是 String 方式

使用步骤如下：

1. 使用 StringRedisTemplate
2. 写入 Redis时，手动把对象序列化为 JSON
3. 读取 Redis 时，手动把读取到的 JSON 反序列化为对象

示例如下：

```java
@SpringBootTest
public class StringRedisTemplateTest {
    @Autowired
    private StringRedisTemplate stringRedisTemplate;
    // JSON 工具
    private static final ObjectMapper objectMapper = new ObjectMapper();

    @Test
    void testStringTemplate() throws JsonProcessingException {
        // 准备对象
        User user = new User("张三", 20);
        // 手动序列化
        String json = objectMapper.writeValueAsString(user);
        // 写入一条数据到 redis
        stringRedisTemplate.opsForValue().set("user:200", json);

        // 读取数据
        String value = stringRedisTemplate.opsForValue().get("user:200");
        // 反序列化
        User user1 = objectMapper.readValue(value, User.class);
        System.out.println("user1 = " + user1);
    }
}
```

![image-20221201171209566](1.%20Redis%20%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86.assets/image-20221201171209566.png)

![image-20221201171224124](1.%20Redis%20%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86.assets/image-20221201171224124.png)

> 可见内存大大减少了

















































































































































